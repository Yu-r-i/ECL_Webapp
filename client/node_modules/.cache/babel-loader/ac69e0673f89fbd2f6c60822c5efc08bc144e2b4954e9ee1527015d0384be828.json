{"ast":null,"code":"export function bound(n, min, max) {\n  return Math.max(Math.min(n, max), min);\n}\nexport function isItem(node) {\n  return node && node.isLeaf;\n}\nexport function isClosed(node) {\n  return node && node.isInternal && !node.isOpen;\n}\nexport function isOpenWithEmptyChildren(node) {\n  var _a;\n  return node && node.isOpen && !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length);\n}\n/**\n * Is first param a descendant of the second param\n */\nexport const isDescendant = (a, b) => {\n  let n = a;\n  while (n) {\n    if (n.id === b.id) return true;\n    n = n.parent;\n  }\n  return false;\n};\nexport const indexOf = node => {\n  if (!node.parent) throw Error(\"Node does not have a parent\");\n  return node.parent.children.findIndex(c => c.id === node.id);\n};\nexport function noop() {}\nexport function dfs(node, id) {\n  if (!node) return null;\n  if (node.id === id) return node;\n  if (node.children) {\n    for (let child of node.children) {\n      const result = dfs(child, id);\n      if (result) return result;\n    }\n  }\n  return null;\n}\nexport function walk(node, fn) {\n  fn(node);\n  if (node.children) {\n    for (let child of node.children) {\n      walk(child, fn);\n    }\n  }\n}\nexport function focusNextElement(target) {\n  const elements = getFocusable(target);\n  let next;\n  for (let i = 0; i < elements.length; ++i) {\n    const item = elements[i];\n    if (item === target) {\n      next = nextItem(elements, i);\n      break;\n    }\n  }\n  // @ts-ignore ??\n  next === null || next === void 0 ? void 0 : next.focus();\n}\nexport function focusPrevElement(target) {\n  const elements = getFocusable(target);\n  let next;\n  for (let i = 0; i < elements.length; ++i) {\n    const item = elements[i];\n    if (item === target) {\n      next = prevItem(elements, i);\n      break;\n    }\n  }\n  // @ts-ignore\n  next === null || next === void 0 ? void 0 : next.focus();\n}\nfunction nextItem(list, index) {\n  if (index + 1 < list.length) {\n    return list[index + 1];\n  } else {\n    return list[0];\n  }\n}\nfunction prevItem(list, index) {\n  if (index - 1 >= 0) {\n    return list[index - 1];\n  } else {\n    return list[list.length - 1];\n  }\n}\nfunction getFocusable(target) {\n  return Array.from(document.querySelectorAll('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"]):not([disabled]), details:not([disabled]), summary:not(:disabled)')).filter(e => e === target || !target.contains(e));\n}\nexport function access(obj, accessor) {\n  if (typeof accessor === \"boolean\") return accessor;\n  if (typeof accessor === \"string\") return obj[accessor];\n  return accessor(obj);\n}\nexport function identifyNull(obj) {\n  if (obj === null) return null;else return identify(obj);\n}\nexport function identify(obj) {\n  return typeof obj === \"string\" ? obj : obj.id;\n}\nexport function mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  return instance => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(instance);\n      } else if (ref != null) {\n        ref.current = instance;\n      }\n    });\n  };\n}\nexport function safeRun(fn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  if (fn) return fn(...args);\n}\nexport function waitFor(fn) {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    function check() {\n      tries += 1;\n      if (tries === 100) reject();\n      if (fn()) resolve();else setTimeout(check, 10);\n    }\n    check();\n  });\n}\nexport function getInsertIndex(tree) {\n  var _a, _b;\n  const focus = tree.focusedNode;\n  if (!focus) return (_b = (_a = tree.root.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n  if (focus.isOpen) return 0;\n  if (focus.parent) return focus.childIndex + 1;\n  return 0;\n}\nexport function getInsertParentId(tree) {\n  const focus = tree.focusedNode;\n  if (!focus) return null;\n  if (focus.isOpen) return focus.id;\n  if (focus.parent && !focus.parent.isRoot) return focus.parent.id;\n  return null;\n}","map":{"version":3,"names":["bound","n","min","max","Math","isItem","node","isLeaf","isClosed","isInternal","isOpen","isOpenWithEmptyChildren","_a","children","length","isDescendant","a","b","id","parent","indexOf","Error","findIndex","c","noop","dfs","child","result","walk","fn","focusNextElement","target","elements","getFocusable","next","i","item","nextItem","focus","focusPrevElement","prevItem","list","index","Array","from","document","querySelectorAll","filter","e","contains","access","obj","accessor","identifyNull","identify","mergeRefs","_len","arguments","refs","_key","instance","forEach","ref","current","safeRun","_len2","args","_key2","waitFor","Promise","resolve","reject","tries","check","setTimeout","getInsertIndex","tree","_b","focusedNode","root","childIndex","getInsertParentId","isRoot"],"sources":["/Users/yuri/GitHub/ECL_Website/root/seminar/client/node_modules/react-arborist/dist/module/utils.js"],"sourcesContent":["export function bound(n, min, max) {\n    return Math.max(Math.min(n, max), min);\n}\nexport function isItem(node) {\n    return node && node.isLeaf;\n}\nexport function isClosed(node) {\n    return node && node.isInternal && !node.isOpen;\n}\nexport function isOpenWithEmptyChildren(node) {\n    var _a;\n    return node && node.isOpen && !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length);\n}\n/**\n * Is first param a descendant of the second param\n */\nexport const isDescendant = (a, b) => {\n    let n = a;\n    while (n) {\n        if (n.id === b.id)\n            return true;\n        n = n.parent;\n    }\n    return false;\n};\nexport const indexOf = (node) => {\n    if (!node.parent)\n        throw Error(\"Node does not have a parent\");\n    return node.parent.children.findIndex((c) => c.id === node.id);\n};\nexport function noop() { }\nexport function dfs(node, id) {\n    if (!node)\n        return null;\n    if (node.id === id)\n        return node;\n    if (node.children) {\n        for (let child of node.children) {\n            const result = dfs(child, id);\n            if (result)\n                return result;\n        }\n    }\n    return null;\n}\nexport function walk(node, fn) {\n    fn(node);\n    if (node.children) {\n        for (let child of node.children) {\n            walk(child, fn);\n        }\n    }\n}\nexport function focusNextElement(target) {\n    const elements = getFocusable(target);\n    let next;\n    for (let i = 0; i < elements.length; ++i) {\n        const item = elements[i];\n        if (item === target) {\n            next = nextItem(elements, i);\n            break;\n        }\n    }\n    // @ts-ignore ??\n    next === null || next === void 0 ? void 0 : next.focus();\n}\nexport function focusPrevElement(target) {\n    const elements = getFocusable(target);\n    let next;\n    for (let i = 0; i < elements.length; ++i) {\n        const item = elements[i];\n        if (item === target) {\n            next = prevItem(elements, i);\n            break;\n        }\n    }\n    // @ts-ignore\n    next === null || next === void 0 ? void 0 : next.focus();\n}\nfunction nextItem(list, index) {\n    if (index + 1 < list.length) {\n        return list[index + 1];\n    }\n    else {\n        return list[0];\n    }\n}\nfunction prevItem(list, index) {\n    if (index - 1 >= 0) {\n        return list[index - 1];\n    }\n    else {\n        return list[list.length - 1];\n    }\n}\nfunction getFocusable(target) {\n    return Array.from(document.querySelectorAll('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"]):not([disabled]), details:not([disabled]), summary:not(:disabled)')).filter((e) => e === target || !target.contains(e));\n}\nexport function access(obj, accessor) {\n    if (typeof accessor === \"boolean\")\n        return accessor;\n    if (typeof accessor === \"string\")\n        return obj[accessor];\n    return accessor(obj);\n}\nexport function identifyNull(obj) {\n    if (obj === null)\n        return null;\n    else\n        return identify(obj);\n}\nexport function identify(obj) {\n    return typeof obj === \"string\" ? obj : obj.id;\n}\nexport function mergeRefs(...refs) {\n    return (instance) => {\n        refs.forEach((ref) => {\n            if (typeof ref === \"function\") {\n                ref(instance);\n            }\n            else if (ref != null) {\n                ref.current = instance;\n            }\n        });\n    };\n}\nexport function safeRun(fn, ...args) {\n    if (fn)\n        return fn(...args);\n}\nexport function waitFor(fn) {\n    return new Promise((resolve, reject) => {\n        let tries = 0;\n        function check() {\n            tries += 1;\n            if (tries === 100)\n                reject();\n            if (fn())\n                resolve();\n            else\n                setTimeout(check, 10);\n        }\n        check();\n    });\n}\nexport function getInsertIndex(tree) {\n    var _a, _b;\n    const focus = tree.focusedNode;\n    if (!focus)\n        return (_b = (_a = tree.root.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n    if (focus.isOpen)\n        return 0;\n    if (focus.parent)\n        return focus.childIndex + 1;\n    return 0;\n}\nexport function getInsertParentId(tree) {\n    const focus = tree.focusedNode;\n    if (!focus)\n        return null;\n    if (focus.isOpen)\n        return focus.id;\n    if (focus.parent && !focus.parent.isRoot)\n        return focus.parent.id;\n    return null;\n}\n"],"mappings":"AAAA,OAAO,SAASA,KAAKA,CAACC,CAAC,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAC/B,OAAOC,IAAI,CAACD,GAAG,CAACC,IAAI,CAACF,GAAG,CAACD,CAAC,EAAEE,GAAG,CAAC,EAAED,GAAG,CAAC;AAC1C;AACA,OAAO,SAASG,MAAMA,CAACC,IAAI,EAAE;EACzB,OAAOA,IAAI,IAAIA,IAAI,CAACC,MAAM;AAC9B;AACA,OAAO,SAASC,QAAQA,CAACF,IAAI,EAAE;EAC3B,OAAOA,IAAI,IAAIA,IAAI,CAACG,UAAU,IAAI,CAACH,IAAI,CAACI,MAAM;AAClD;AACA,OAAO,SAASC,uBAAuBA,CAACL,IAAI,EAAE;EAC1C,IAAIM,EAAE;EACN,OAAON,IAAI,IAAIA,IAAI,CAACI,MAAM,IAAI,EAAE,CAACE,EAAE,GAAGN,IAAI,CAACO,QAAQ,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,MAAM,CAAC;AACxG;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EAClC,IAAIhB,CAAC,GAAGe,CAAC;EACT,OAAOf,CAAC,EAAE;IACN,IAAIA,CAAC,CAACiB,EAAE,KAAKD,CAAC,CAACC,EAAE,EACb,OAAO,IAAI;IACfjB,CAAC,GAAGA,CAAC,CAACkB,MAAM;EAChB;EACA,OAAO,KAAK;AAChB,CAAC;AACD,OAAO,MAAMC,OAAO,GAAId,IAAI,IAAK;EAC7B,IAAI,CAACA,IAAI,CAACa,MAAM,EACZ,MAAME,KAAK,CAAC,6BAA6B,CAAC;EAC9C,OAAOf,IAAI,CAACa,MAAM,CAACN,QAAQ,CAACS,SAAS,CAAEC,CAAC,IAAKA,CAAC,CAACL,EAAE,KAAKZ,IAAI,CAACY,EAAE,CAAC;AAClE,CAAC;AACD,OAAO,SAASM,IAAIA,CAAA,EAAG,CAAE;AACzB,OAAO,SAASC,GAAGA,CAACnB,IAAI,EAAEY,EAAE,EAAE;EAC1B,IAAI,CAACZ,IAAI,EACL,OAAO,IAAI;EACf,IAAIA,IAAI,CAACY,EAAE,KAAKA,EAAE,EACd,OAAOZ,IAAI;EACf,IAAIA,IAAI,CAACO,QAAQ,EAAE;IACf,KAAK,IAAIa,KAAK,IAAIpB,IAAI,CAACO,QAAQ,EAAE;MAC7B,MAAMc,MAAM,GAAGF,GAAG,CAACC,KAAK,EAAER,EAAE,CAAC;MAC7B,IAAIS,MAAM,EACN,OAAOA,MAAM;IACrB;EACJ;EACA,OAAO,IAAI;AACf;AACA,OAAO,SAASC,IAAIA,CAACtB,IAAI,EAAEuB,EAAE,EAAE;EAC3BA,EAAE,CAACvB,IAAI,CAAC;EACR,IAAIA,IAAI,CAACO,QAAQ,EAAE;IACf,KAAK,IAAIa,KAAK,IAAIpB,IAAI,CAACO,QAAQ,EAAE;MAC7Be,IAAI,CAACF,KAAK,EAAEG,EAAE,CAAC;IACnB;EACJ;AACJ;AACA,OAAO,SAASC,gBAAgBA,CAACC,MAAM,EAAE;EACrC,MAAMC,QAAQ,GAAGC,YAAY,CAACF,MAAM,CAAC;EACrC,IAAIG,IAAI;EACR,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAAClB,MAAM,EAAE,EAAEqB,CAAC,EAAE;IACtC,MAAMC,IAAI,GAAGJ,QAAQ,CAACG,CAAC,CAAC;IACxB,IAAIC,IAAI,KAAKL,MAAM,EAAE;MACjBG,IAAI,GAAGG,QAAQ,CAACL,QAAQ,EAAEG,CAAC,CAAC;MAC5B;IACJ;EACJ;EACA;EACAD,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACI,KAAK,CAAC,CAAC;AAC5D;AACA,OAAO,SAASC,gBAAgBA,CAACR,MAAM,EAAE;EACrC,MAAMC,QAAQ,GAAGC,YAAY,CAACF,MAAM,CAAC;EACrC,IAAIG,IAAI;EACR,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAAClB,MAAM,EAAE,EAAEqB,CAAC,EAAE;IACtC,MAAMC,IAAI,GAAGJ,QAAQ,CAACG,CAAC,CAAC;IACxB,IAAIC,IAAI,KAAKL,MAAM,EAAE;MACjBG,IAAI,GAAGM,QAAQ,CAACR,QAAQ,EAAEG,CAAC,CAAC;MAC5B;IACJ;EACJ;EACA;EACAD,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACI,KAAK,CAAC,CAAC;AAC5D;AACA,SAASD,QAAQA,CAACI,IAAI,EAAEC,KAAK,EAAE;EAC3B,IAAIA,KAAK,GAAG,CAAC,GAAGD,IAAI,CAAC3B,MAAM,EAAE;IACzB,OAAO2B,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;EAC1B,CAAC,MACI;IACD,OAAOD,IAAI,CAAC,CAAC,CAAC;EAClB;AACJ;AACA,SAASD,QAAQA,CAACC,IAAI,EAAEC,KAAK,EAAE;EAC3B,IAAIA,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE;IAChB,OAAOD,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;EAC1B,CAAC,MACI;IACD,OAAOD,IAAI,CAACA,IAAI,CAAC3B,MAAM,GAAG,CAAC,CAAC;EAChC;AACJ;AACA,SAASmB,YAAYA,CAACF,MAAM,EAAE;EAC1B,OAAOY,KAAK,CAACC,IAAI,CAACC,QAAQ,CAACC,gBAAgB,CAAC,2MAA2M,CAAC,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,KAAKjB,MAAM,IAAI,CAACA,MAAM,CAACkB,QAAQ,CAACD,CAAC,CAAC,CAAC;AAChT;AACA,OAAO,SAASE,MAAMA,CAACC,GAAG,EAAEC,QAAQ,EAAE;EAClC,IAAI,OAAOA,QAAQ,KAAK,SAAS,EAC7B,OAAOA,QAAQ;EACnB,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAC5B,OAAOD,GAAG,CAACC,QAAQ,CAAC;EACxB,OAAOA,QAAQ,CAACD,GAAG,CAAC;AACxB;AACA,OAAO,SAASE,YAAYA,CAACF,GAAG,EAAE;EAC9B,IAAIA,GAAG,KAAK,IAAI,EACZ,OAAO,IAAI,CAAC,KAEZ,OAAOG,QAAQ,CAACH,GAAG,CAAC;AAC5B;AACA,OAAO,SAASG,QAAQA,CAACH,GAAG,EAAE;EAC1B,OAAO,OAAOA,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGA,GAAG,CAACjC,EAAE;AACjD;AACA,OAAO,SAASqC,SAASA,CAAA,EAAU;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAA3C,MAAA,EAAN4C,IAAI,OAAAf,KAAA,CAAAa,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAAJD,IAAI,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;EAAA;EAC7B,OAAQC,QAAQ,IAAK;IACjBF,IAAI,CAACG,OAAO,CAAEC,GAAG,IAAK;MAClB,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;QAC3BA,GAAG,CAACF,QAAQ,CAAC;MACjB,CAAC,MACI,IAAIE,GAAG,IAAI,IAAI,EAAE;QAClBA,GAAG,CAACC,OAAO,GAAGH,QAAQ;MAC1B;IACJ,CAAC,CAAC;EACN,CAAC;AACL;AACA,OAAO,SAASI,OAAOA,CAACnC,EAAE,EAAW;EAAA,SAAAoC,KAAA,GAAAR,SAAA,CAAA3C,MAAA,EAANoD,IAAI,OAAAvB,KAAA,CAAAsB,KAAA,OAAAA,KAAA,WAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;IAAJD,IAAI,CAAAC,KAAA,QAAAV,SAAA,CAAAU,KAAA;EAAA;EAC/B,IAAItC,EAAE,EACF,OAAOA,EAAE,CAAC,GAAGqC,IAAI,CAAC;AAC1B;AACA,OAAO,SAASE,OAAOA,CAACvC,EAAE,EAAE;EACxB,OAAO,IAAIwC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACpC,IAAIC,KAAK,GAAG,CAAC;IACb,SAASC,KAAKA,CAAA,EAAG;MACbD,KAAK,IAAI,CAAC;MACV,IAAIA,KAAK,KAAK,GAAG,EACbD,MAAM,CAAC,CAAC;MACZ,IAAI1C,EAAE,CAAC,CAAC,EACJyC,OAAO,CAAC,CAAC,CAAC,KAEVI,UAAU,CAACD,KAAK,EAAE,EAAE,CAAC;IAC7B;IACAA,KAAK,CAAC,CAAC;EACX,CAAC,CAAC;AACN;AACA,OAAO,SAASE,cAAcA,CAACC,IAAI,EAAE;EACjC,IAAIhE,EAAE,EAAEiE,EAAE;EACV,MAAMvC,KAAK,GAAGsC,IAAI,CAACE,WAAW;EAC9B,IAAI,CAACxC,KAAK,EACN,OAAO,CAACuC,EAAE,GAAG,CAACjE,EAAE,GAAGgE,IAAI,CAACG,IAAI,CAAClE,QAAQ,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,MAAM,MAAM,IAAI,IAAI+D,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;EAC7H,IAAIvC,KAAK,CAAC5B,MAAM,EACZ,OAAO,CAAC;EACZ,IAAI4B,KAAK,CAACnB,MAAM,EACZ,OAAOmB,KAAK,CAAC0C,UAAU,GAAG,CAAC;EAC/B,OAAO,CAAC;AACZ;AACA,OAAO,SAASC,iBAAiBA,CAACL,IAAI,EAAE;EACpC,MAAMtC,KAAK,GAAGsC,IAAI,CAACE,WAAW;EAC9B,IAAI,CAACxC,KAAK,EACN,OAAO,IAAI;EACf,IAAIA,KAAK,CAAC5B,MAAM,EACZ,OAAO4B,KAAK,CAACpB,EAAE;EACnB,IAAIoB,KAAK,CAACnB,MAAM,IAAI,CAACmB,KAAK,CAACnB,MAAM,CAAC+D,MAAM,EACpC,OAAO5C,KAAK,CAACnB,MAAM,CAACD,EAAE;EAC1B,OAAO,IAAI;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}