{"ast":null,"code":"import { bound, indexOf, isClosed, isItem, isOpenWithEmptyChildren } from \"../utils\";\nfunction measureHover(el, offset) {\n  const rect = el.getBoundingClientRect();\n  const x = offset.x - Math.round(rect.x);\n  const y = offset.y - Math.round(rect.y);\n  const height = rect.height;\n  const inTopHalf = y < height / 2;\n  const inBottomHalf = !inTopHalf;\n  const pad = height / 4;\n  const inMiddle = y > pad && y < height - pad;\n  const atTop = !inMiddle && inTopHalf;\n  const atBottom = !inMiddle && inBottomHalf;\n  return {\n    x,\n    inTopHalf,\n    inBottomHalf,\n    inMiddle,\n    atTop,\n    atBottom\n  };\n}\nfunction getNodesAroundCursor(node, prev, next, hover) {\n  if (!node) {\n    // We're hovering over the empty part of the list, not over an item,\n    // Put the cursor below the last item which is \"prev\"\n    return [prev, null];\n  }\n  if (node.isInternal) {\n    if (hover.atTop) {\n      return [prev, node];\n    } else if (hover.inMiddle) {\n      return [node, node];\n    } else {\n      return [node, next];\n    }\n  } else {\n    if (hover.inTopHalf) {\n      return [prev, node];\n    } else {\n      return [node, next];\n    }\n  }\n}\nfunction dropAt(parentId, index) {\n  return {\n    parentId: parentId || null,\n    index\n  };\n}\nfunction lineCursor(index, level) {\n  return {\n    type: \"line\",\n    index,\n    level\n  };\n}\nfunction noCursor() {\n  return {\n    type: \"none\"\n  };\n}\nfunction highlightCursor(id) {\n  return {\n    type: \"highlight\",\n    id\n  };\n}\nfunction walkUpFrom(node, level) {\n  var _a;\n  let drop = node;\n  while (drop.parent && drop.level > level) {\n    drop = drop.parent;\n  }\n  const parentId = ((_a = drop.parent) === null || _a === void 0 ? void 0 : _a.id) || null;\n  const index = indexOf(drop) + 1;\n  return {\n    parentId,\n    index\n  };\n}\n/**\n * This is the most complex, tricky function in the whole repo.\n */\nexport function computeDrop(args) {\n  var _a;\n  const hover = measureHover(args.element, args.offset);\n  const indent = args.indent;\n  const hoverLevel = Math.round(Math.max(0, hover.x - indent) / indent);\n  const {\n    node,\n    nextNode,\n    prevNode\n  } = args;\n  const [above, below] = getNodesAroundCursor(node, prevNode, nextNode, hover);\n  /* Hovering over the middle of a folder */\n  if (node && node.isInternal && hover.inMiddle) {\n    return {\n      drop: dropAt(node.id, null),\n      cursor: highlightCursor(node.id)\n    };\n  }\n  /*\n   * Now we only need to care about the node above the cursor\n   * -----------                            -------\n   */\n  /* There is no node above the cursor line */\n  if (!above) {\n    return {\n      drop: dropAt((_a = below === null || below === void 0 ? void 0 : below.parent) === null || _a === void 0 ? void 0 : _a.id, 0),\n      cursor: lineCursor(0, 0)\n    };\n  }\n  /* The node above the cursor line is an item */\n  if (isItem(above)) {\n    const level = bound(hoverLevel, (below === null || below === void 0 ? void 0 : below.level) || 0, above.level);\n    return {\n      drop: walkUpFrom(above, level),\n      cursor: lineCursor(above.rowIndex + 1, level)\n    };\n  }\n  /* The node above the cursor line is a closed folder */\n  if (isClosed(above)) {\n    const level = bound(hoverLevel, (below === null || below === void 0 ? void 0 : below.level) || 0, above.level);\n    return {\n      drop: walkUpFrom(above, level),\n      cursor: lineCursor(above.rowIndex + 1, level)\n    };\n  }\n  /* The node above the cursor line is an open folder with no children */\n  if (isOpenWithEmptyChildren(above)) {\n    const level = bound(hoverLevel, 0, above.level + 1);\n    if (level > above.level) {\n      /* Will be the first child of the empty folder */\n      return {\n        drop: dropAt(above.id, 0),\n        cursor: lineCursor(above.rowIndex + 1, level)\n      };\n    } else {\n      /* Will be a sibling or grandsibling of the empty folder */\n      return {\n        drop: walkUpFrom(above, level),\n        cursor: lineCursor(above.rowIndex + 1, level)\n      };\n    }\n  }\n  /* The node above the cursor is a an open folder with children */\n  return {\n    drop: dropAt(above === null || above === void 0 ? void 0 : above.id, 0),\n    cursor: lineCursor(above.rowIndex + 1, above.level + 1)\n  };\n}","map":{"version":3,"names":["bound","indexOf","isClosed","isItem","isOpenWithEmptyChildren","measureHover","el","offset","rect","getBoundingClientRect","x","Math","round","y","height","inTopHalf","inBottomHalf","pad","inMiddle","atTop","atBottom","getNodesAroundCursor","node","prev","next","hover","isInternal","dropAt","parentId","index","lineCursor","level","type","noCursor","highlightCursor","id","walkUpFrom","_a","drop","parent","computeDrop","args","element","indent","hoverLevel","max","nextNode","prevNode","above","below","cursor","rowIndex"],"sources":["/Users/yuri/GitHub/ECL_Website/root/seminar/client/node_modules/react-arborist/dist/module/dnd/compute-drop.js"],"sourcesContent":["import { bound, indexOf, isClosed, isItem, isOpenWithEmptyChildren, } from \"../utils\";\nfunction measureHover(el, offset) {\n    const rect = el.getBoundingClientRect();\n    const x = offset.x - Math.round(rect.x);\n    const y = offset.y - Math.round(rect.y);\n    const height = rect.height;\n    const inTopHalf = y < height / 2;\n    const inBottomHalf = !inTopHalf;\n    const pad = height / 4;\n    const inMiddle = y > pad && y < height - pad;\n    const atTop = !inMiddle && inTopHalf;\n    const atBottom = !inMiddle && inBottomHalf;\n    return { x, inTopHalf, inBottomHalf, inMiddle, atTop, atBottom };\n}\nfunction getNodesAroundCursor(node, prev, next, hover) {\n    if (!node) {\n        // We're hovering over the empty part of the list, not over an item,\n        // Put the cursor below the last item which is \"prev\"\n        return [prev, null];\n    }\n    if (node.isInternal) {\n        if (hover.atTop) {\n            return [prev, node];\n        }\n        else if (hover.inMiddle) {\n            return [node, node];\n        }\n        else {\n            return [node, next];\n        }\n    }\n    else {\n        if (hover.inTopHalf) {\n            return [prev, node];\n        }\n        else {\n            return [node, next];\n        }\n    }\n}\nfunction dropAt(parentId, index) {\n    return { parentId: parentId || null, index };\n}\nfunction lineCursor(index, level) {\n    return {\n        type: \"line\",\n        index,\n        level,\n    };\n}\nfunction noCursor() {\n    return {\n        type: \"none\",\n    };\n}\nfunction highlightCursor(id) {\n    return {\n        type: \"highlight\",\n        id,\n    };\n}\nfunction walkUpFrom(node, level) {\n    var _a;\n    let drop = node;\n    while (drop.parent && drop.level > level) {\n        drop = drop.parent;\n    }\n    const parentId = ((_a = drop.parent) === null || _a === void 0 ? void 0 : _a.id) || null;\n    const index = indexOf(drop) + 1;\n    return { parentId, index };\n}\n/**\n * This is the most complex, tricky function in the whole repo.\n */\nexport function computeDrop(args) {\n    var _a;\n    const hover = measureHover(args.element, args.offset);\n    const indent = args.indent;\n    const hoverLevel = Math.round(Math.max(0, hover.x - indent) / indent);\n    const { node, nextNode, prevNode } = args;\n    const [above, below] = getNodesAroundCursor(node, prevNode, nextNode, hover);\n    /* Hovering over the middle of a folder */\n    if (node && node.isInternal && hover.inMiddle) {\n        return {\n            drop: dropAt(node.id, null),\n            cursor: highlightCursor(node.id),\n        };\n    }\n    /*\n     * Now we only need to care about the node above the cursor\n     * -----------                            -------\n     */\n    /* There is no node above the cursor line */\n    if (!above) {\n        return {\n            drop: dropAt((_a = below === null || below === void 0 ? void 0 : below.parent) === null || _a === void 0 ? void 0 : _a.id, 0),\n            cursor: lineCursor(0, 0),\n        };\n    }\n    /* The node above the cursor line is an item */\n    if (isItem(above)) {\n        const level = bound(hoverLevel, (below === null || below === void 0 ? void 0 : below.level) || 0, above.level);\n        return {\n            drop: walkUpFrom(above, level),\n            cursor: lineCursor(above.rowIndex + 1, level),\n        };\n    }\n    /* The node above the cursor line is a closed folder */\n    if (isClosed(above)) {\n        const level = bound(hoverLevel, (below === null || below === void 0 ? void 0 : below.level) || 0, above.level);\n        return {\n            drop: walkUpFrom(above, level),\n            cursor: lineCursor(above.rowIndex + 1, level),\n        };\n    }\n    /* The node above the cursor line is an open folder with no children */\n    if (isOpenWithEmptyChildren(above)) {\n        const level = bound(hoverLevel, 0, above.level + 1);\n        if (level > above.level) {\n            /* Will be the first child of the empty folder */\n            return {\n                drop: dropAt(above.id, 0),\n                cursor: lineCursor(above.rowIndex + 1, level),\n            };\n        }\n        else {\n            /* Will be a sibling or grandsibling of the empty folder */\n            return {\n                drop: walkUpFrom(above, level),\n                cursor: lineCursor(above.rowIndex + 1, level),\n            };\n        }\n    }\n    /* The node above the cursor is a an open folder with children */\n    return {\n        drop: dropAt(above === null || above === void 0 ? void 0 : above.id, 0),\n        cursor: lineCursor(above.rowIndex + 1, above.level + 1),\n    };\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,uBAAuB,QAAS,UAAU;AACrF,SAASC,YAAYA,CAACC,EAAE,EAAEC,MAAM,EAAE;EAC9B,MAAMC,IAAI,GAAGF,EAAE,CAACG,qBAAqB,CAAC,CAAC;EACvC,MAAMC,CAAC,GAAGH,MAAM,CAACG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAACE,CAAC,CAAC;EACvC,MAAMG,CAAC,GAAGN,MAAM,CAACM,CAAC,GAAGF,IAAI,CAACC,KAAK,CAACJ,IAAI,CAACK,CAAC,CAAC;EACvC,MAAMC,MAAM,GAAGN,IAAI,CAACM,MAAM;EAC1B,MAAMC,SAAS,GAAGF,CAAC,GAAGC,MAAM,GAAG,CAAC;EAChC,MAAME,YAAY,GAAG,CAACD,SAAS;EAC/B,MAAME,GAAG,GAAGH,MAAM,GAAG,CAAC;EACtB,MAAMI,QAAQ,GAAGL,CAAC,GAAGI,GAAG,IAAIJ,CAAC,GAAGC,MAAM,GAAGG,GAAG;EAC5C,MAAME,KAAK,GAAG,CAACD,QAAQ,IAAIH,SAAS;EACpC,MAAMK,QAAQ,GAAG,CAACF,QAAQ,IAAIF,YAAY;EAC1C,OAAO;IAAEN,CAAC;IAAEK,SAAS;IAAEC,YAAY;IAAEE,QAAQ;IAAEC,KAAK;IAAEC;EAAS,CAAC;AACpE;AACA,SAASC,oBAAoBA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;EACnD,IAAI,CAACH,IAAI,EAAE;IACP;IACA;IACA,OAAO,CAACC,IAAI,EAAE,IAAI,CAAC;EACvB;EACA,IAAID,IAAI,CAACI,UAAU,EAAE;IACjB,IAAID,KAAK,CAACN,KAAK,EAAE;MACb,OAAO,CAACI,IAAI,EAAED,IAAI,CAAC;IACvB,CAAC,MACI,IAAIG,KAAK,CAACP,QAAQ,EAAE;MACrB,OAAO,CAACI,IAAI,EAAEA,IAAI,CAAC;IACvB,CAAC,MACI;MACD,OAAO,CAACA,IAAI,EAAEE,IAAI,CAAC;IACvB;EACJ,CAAC,MACI;IACD,IAAIC,KAAK,CAACV,SAAS,EAAE;MACjB,OAAO,CAACQ,IAAI,EAAED,IAAI,CAAC;IACvB,CAAC,MACI;MACD,OAAO,CAACA,IAAI,EAAEE,IAAI,CAAC;IACvB;EACJ;AACJ;AACA,SAASG,MAAMA,CAACC,QAAQ,EAAEC,KAAK,EAAE;EAC7B,OAAO;IAAED,QAAQ,EAAEA,QAAQ,IAAI,IAAI;IAAEC;EAAM,CAAC;AAChD;AACA,SAASC,UAAUA,CAACD,KAAK,EAAEE,KAAK,EAAE;EAC9B,OAAO;IACHC,IAAI,EAAE,MAAM;IACZH,KAAK;IACLE;EACJ,CAAC;AACL;AACA,SAASE,QAAQA,CAAA,EAAG;EAChB,OAAO;IACHD,IAAI,EAAE;EACV,CAAC;AACL;AACA,SAASE,eAAeA,CAACC,EAAE,EAAE;EACzB,OAAO;IACHH,IAAI,EAAE,WAAW;IACjBG;EACJ,CAAC;AACL;AACA,SAASC,UAAUA,CAACd,IAAI,EAAES,KAAK,EAAE;EAC7B,IAAIM,EAAE;EACN,IAAIC,IAAI,GAAGhB,IAAI;EACf,OAAOgB,IAAI,CAACC,MAAM,IAAID,IAAI,CAACP,KAAK,GAAGA,KAAK,EAAE;IACtCO,IAAI,GAAGA,IAAI,CAACC,MAAM;EACtB;EACA,MAAMX,QAAQ,GAAG,CAAC,CAACS,EAAE,GAAGC,IAAI,CAACC,MAAM,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACF,EAAE,KAAK,IAAI;EACxF,MAAMN,KAAK,GAAG5B,OAAO,CAACqC,IAAI,CAAC,GAAG,CAAC;EAC/B,OAAO;IAAEV,QAAQ;IAAEC;EAAM,CAAC;AAC9B;AACA;AACA;AACA;AACA,OAAO,SAASW,WAAWA,CAACC,IAAI,EAAE;EAC9B,IAAIJ,EAAE;EACN,MAAMZ,KAAK,GAAGpB,YAAY,CAACoC,IAAI,CAACC,OAAO,EAAED,IAAI,CAAClC,MAAM,CAAC;EACrD,MAAMoC,MAAM,GAAGF,IAAI,CAACE,MAAM;EAC1B,MAAMC,UAAU,GAAGjC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkC,GAAG,CAAC,CAAC,EAAEpB,KAAK,CAACf,CAAC,GAAGiC,MAAM,CAAC,GAAGA,MAAM,CAAC;EACrE,MAAM;IAAErB,IAAI;IAAEwB,QAAQ;IAAEC;EAAS,CAAC,GAAGN,IAAI;EACzC,MAAM,CAACO,KAAK,EAAEC,KAAK,CAAC,GAAG5B,oBAAoB,CAACC,IAAI,EAAEyB,QAAQ,EAAED,QAAQ,EAAErB,KAAK,CAAC;EAC5E;EACA,IAAIH,IAAI,IAAIA,IAAI,CAACI,UAAU,IAAID,KAAK,CAACP,QAAQ,EAAE;IAC3C,OAAO;MACHoB,IAAI,EAAEX,MAAM,CAACL,IAAI,CAACa,EAAE,EAAE,IAAI,CAAC;MAC3Be,MAAM,EAAEhB,eAAe,CAACZ,IAAI,CAACa,EAAE;IACnC,CAAC;EACL;EACA;AACJ;AACA;AACA;EACI;EACA,IAAI,CAACa,KAAK,EAAE;IACR,OAAO;MACHV,IAAI,EAAEX,MAAM,CAAC,CAACU,EAAE,GAAGY,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACV,MAAM,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACF,EAAE,EAAE,CAAC,CAAC;MAC7He,MAAM,EAAEpB,UAAU,CAAC,CAAC,EAAE,CAAC;IAC3B,CAAC;EACL;EACA;EACA,IAAI3B,MAAM,CAAC6C,KAAK,CAAC,EAAE;IACf,MAAMjB,KAAK,GAAG/B,KAAK,CAAC4C,UAAU,EAAE,CAACK,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAClB,KAAK,KAAK,CAAC,EAAEiB,KAAK,CAACjB,KAAK,CAAC;IAC9G,OAAO;MACHO,IAAI,EAAEF,UAAU,CAACY,KAAK,EAAEjB,KAAK,CAAC;MAC9BmB,MAAM,EAAEpB,UAAU,CAACkB,KAAK,CAACG,QAAQ,GAAG,CAAC,EAAEpB,KAAK;IAChD,CAAC;EACL;EACA;EACA,IAAI7B,QAAQ,CAAC8C,KAAK,CAAC,EAAE;IACjB,MAAMjB,KAAK,GAAG/B,KAAK,CAAC4C,UAAU,EAAE,CAACK,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAClB,KAAK,KAAK,CAAC,EAAEiB,KAAK,CAACjB,KAAK,CAAC;IAC9G,OAAO;MACHO,IAAI,EAAEF,UAAU,CAACY,KAAK,EAAEjB,KAAK,CAAC;MAC9BmB,MAAM,EAAEpB,UAAU,CAACkB,KAAK,CAACG,QAAQ,GAAG,CAAC,EAAEpB,KAAK;IAChD,CAAC;EACL;EACA;EACA,IAAI3B,uBAAuB,CAAC4C,KAAK,CAAC,EAAE;IAChC,MAAMjB,KAAK,GAAG/B,KAAK,CAAC4C,UAAU,EAAE,CAAC,EAAEI,KAAK,CAACjB,KAAK,GAAG,CAAC,CAAC;IACnD,IAAIA,KAAK,GAAGiB,KAAK,CAACjB,KAAK,EAAE;MACrB;MACA,OAAO;QACHO,IAAI,EAAEX,MAAM,CAACqB,KAAK,CAACb,EAAE,EAAE,CAAC,CAAC;QACzBe,MAAM,EAAEpB,UAAU,CAACkB,KAAK,CAACG,QAAQ,GAAG,CAAC,EAAEpB,KAAK;MAChD,CAAC;IACL,CAAC,MACI;MACD;MACA,OAAO;QACHO,IAAI,EAAEF,UAAU,CAACY,KAAK,EAAEjB,KAAK,CAAC;QAC9BmB,MAAM,EAAEpB,UAAU,CAACkB,KAAK,CAACG,QAAQ,GAAG,CAAC,EAAEpB,KAAK;MAChD,CAAC;IACL;EACJ;EACA;EACA,OAAO;IACHO,IAAI,EAAEX,MAAM,CAACqB,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACb,EAAE,EAAE,CAAC,CAAC;IACvEe,MAAM,EAAEpB,UAAU,CAACkB,KAAK,CAACG,QAAQ,GAAG,CAAC,EAAEH,KAAK,CAACjB,KAAK,GAAG,CAAC;EAC1D,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}