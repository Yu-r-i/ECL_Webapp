{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { FixedSizeList } from \"react-window\";\nimport { useDataUpdates, useTreeApi } from \"../context\";\nimport { focusNextElement, focusPrevElement } from \"../utils\";\nimport { ListOuterElement } from \"./list-outer-element\";\nimport { ListInnerElement } from \"./list-inner-element\";\nimport { RowContainer } from \"./row-container\";\nlet focusSearchTerm = \"\";\nlet timeoutId = null;\n/**\n * All these keyboard shortcuts seem like they should be configurable.\n * Each operation should be a given a name and separated from\n * the event handler. Future clean up welcome.\n */\nexport function DefaultContainer() {\n  useDataUpdates();\n  const tree = useTreeApi();\n  return _jsx(\"div\", {\n    role: \"tree\",\n    style: {\n      height: tree.height,\n      width: tree.width,\n      minHeight: 0,\n      minWidth: 0\n    },\n    onContextMenu: tree.props.onContextMenu,\n    onClick: tree.props.onClick,\n    tabIndex: 0,\n    onFocus: e => {\n      if (!e.currentTarget.contains(e.relatedTarget)) {\n        tree.onFocus();\n      }\n    },\n    onBlur: e => {\n      if (!e.currentTarget.contains(e.relatedTarget)) {\n        tree.onBlur();\n      }\n    },\n    onKeyDown: e => {\n      var _a;\n      if (tree.isEditing) {\n        return;\n      }\n      if (e.key === \"Backspace\") {\n        if (!tree.props.onDelete) return;\n        const ids = Array.from(tree.selectedIds);\n        if (ids.length > 1) {\n          let nextFocus = tree.mostRecentNode;\n          while (nextFocus && nextFocus.isSelected) {\n            nextFocus = nextFocus.nextSibling;\n          }\n          if (!nextFocus) nextFocus = tree.lastNode;\n          tree.focus(nextFocus, {\n            scroll: false\n          });\n          tree.delete(Array.from(ids));\n        } else {\n          const node = tree.focusedNode;\n          if (node) {\n            const sib = node.nextSibling;\n            const parent = node.parent;\n            tree.focus(sib || parent, {\n              scroll: false\n            });\n            tree.delete(node);\n          }\n        }\n        return;\n      }\n      if (e.key === \"Tab\" && !e.shiftKey) {\n        e.preventDefault();\n        focusNextElement(e.currentTarget);\n        return;\n      }\n      if (e.key === \"Tab\" && e.shiftKey) {\n        e.preventDefault();\n        focusPrevElement(e.currentTarget);\n        return;\n      }\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        const next = tree.nextNode;\n        if (e.metaKey) {\n          tree.select(tree.focusedNode);\n          tree.activate(tree.focusedNode);\n          return;\n        } else if (!e.shiftKey || tree.props.disableMultiSelection) {\n          tree.focus(next);\n          return;\n        } else {\n          if (!next) return;\n          const current = tree.focusedNode;\n          if (!current) {\n            tree.focus(tree.firstNode);\n          } else if (current.isSelected) {\n            tree.selectContiguous(next);\n          } else {\n            tree.selectMulti(next);\n          }\n          return;\n        }\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        const prev = tree.prevNode;\n        if (!e.shiftKey || tree.props.disableMultiSelection) {\n          tree.focus(prev);\n          return;\n        } else {\n          if (!prev) return;\n          const current = tree.focusedNode;\n          if (!current) {\n            tree.focus(tree.lastNode); // ?\n          } else if (current.isSelected) {\n            tree.selectContiguous(prev);\n          } else {\n            tree.selectMulti(prev);\n          }\n          return;\n        }\n      }\n      if (e.key === \"ArrowRight\") {\n        const node = tree.focusedNode;\n        if (!node) return;\n        if (node.isInternal && node.isOpen) {\n          tree.focus(tree.nextNode);\n        } else if (node.isInternal) tree.open(node.id);\n        return;\n      }\n      if (e.key === \"ArrowLeft\") {\n        const node = tree.focusedNode;\n        if (!node || node.isRoot) return;\n        if (node.isInternal && node.isOpen) tree.close(node.id);else if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)) {\n          tree.focus(node.parent);\n        }\n        return;\n      }\n      if (e.key === \"a\" && e.metaKey && !tree.props.disableMultiSelection) {\n        e.preventDefault();\n        tree.selectAll();\n        return;\n      }\n      if (e.key === \"a\" && !e.metaKey && tree.props.onCreate) {\n        tree.createLeaf();\n        return;\n      }\n      if (e.key === \"A\" && !e.metaKey) {\n        if (!tree.props.onCreate) return;\n        tree.createInternal();\n        return;\n      }\n      if (e.key === \"Home\") {\n        // add shift keys\n        e.preventDefault();\n        tree.focus(tree.firstNode);\n        return;\n      }\n      if (e.key === \"End\") {\n        // add shift keys\n        e.preventDefault();\n        tree.focus(tree.lastNode);\n        return;\n      }\n      if (e.key === \"Enter\") {\n        const node = tree.focusedNode;\n        if (!node) return;\n        if (!node.isEditable || !tree.props.onRename) return;\n        setTimeout(() => {\n          if (node) tree.edit(node);\n        });\n        return;\n      }\n      if (e.key === \" \") {\n        e.preventDefault();\n        const node = tree.focusedNode;\n        if (!node) return;\n        if (node.isLeaf) {\n          node.select();\n          node.activate();\n        } else {\n          node.toggle();\n        }\n        return;\n      }\n      if (e.key === \"*\") {\n        const node = tree.focusedNode;\n        if (!node) return;\n        tree.openSiblings(node);\n        return;\n      }\n      if (e.key === \"PageUp\") {\n        e.preventDefault();\n        tree.pageUp();\n        return;\n      }\n      if (e.key === \"PageDown\") {\n        e.preventDefault();\n        tree.pageDown();\n      }\n      // If they type a sequence of characters\n      // collect them. Reset them after a timeout.\n      // Use it to search the tree for a node, then focus it.\n      // Clean this up a bit later\n      clearTimeout(timeoutId);\n      focusSearchTerm += e.key;\n      timeoutId = setTimeout(() => {\n        focusSearchTerm = \"\";\n      }, 600);\n      const node = tree.visibleNodes.find(n => {\n        // @ts-ignore\n        const name = n.data.name;\n        if (typeof name === \"string\") {\n          return name.toLowerCase().startsWith(focusSearchTerm);\n        } else return false;\n      });\n      if (node) tree.focus(node.id);\n    },\n    children: _jsx(FixedSizeList, {\n      className: tree.props.className,\n      outerRef: tree.listEl,\n      itemCount: tree.visibleNodes.length,\n      height: tree.height,\n      width: tree.width,\n      itemSize: tree.rowHeight,\n      overscanCount: tree.overscanCount,\n      itemKey: index => {\n        var _a;\n        return ((_a = tree.visibleNodes[index]) === null || _a === void 0 ? void 0 : _a.id) || index;\n      },\n      outerElementType: ListOuterElement,\n      innerElementType: ListInnerElement,\n      onScroll: tree.props.onScroll,\n      onItemsRendered: tree.onItemsRendered.bind(tree),\n      ref: tree.list,\n      children: RowContainer\n    })\n  });\n}","map":{"version":3,"names":["jsx","_jsx","FixedSizeList","useDataUpdates","useTreeApi","focusNextElement","focusPrevElement","ListOuterElement","ListInnerElement","RowContainer","focusSearchTerm","timeoutId","DefaultContainer","tree","role","style","height","width","minHeight","minWidth","onContextMenu","props","onClick","tabIndex","onFocus","e","currentTarget","contains","relatedTarget","onBlur","onKeyDown","_a","isEditing","key","onDelete","ids","Array","from","selectedIds","length","nextFocus","mostRecentNode","isSelected","nextSibling","lastNode","focus","scroll","delete","node","focusedNode","sib","parent","shiftKey","preventDefault","next","nextNode","metaKey","select","activate","disableMultiSelection","current","firstNode","selectContiguous","selectMulti","prev","prevNode","isInternal","isOpen","open","id","isRoot","close","selectAll","onCreate","createLeaf","createInternal","isEditable","onRename","setTimeout","edit","isLeaf","toggle","openSiblings","pageUp","pageDown","clearTimeout","visibleNodes","find","n","name","data","toLowerCase","startsWith","children","className","outerRef","listEl","itemCount","itemSize","rowHeight","overscanCount","itemKey","index","outerElementType","innerElementType","onScroll","onItemsRendered","bind","ref","list"],"sources":["/Users/yuri/GitHub/ECL_Website/root/seminar/client/node_modules/react-arborist/dist/module/components/default-container.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { FixedSizeList } from \"react-window\";\nimport { useDataUpdates, useTreeApi } from \"../context\";\nimport { focusNextElement, focusPrevElement } from \"../utils\";\nimport { ListOuterElement } from \"./list-outer-element\";\nimport { ListInnerElement } from \"./list-inner-element\";\nimport { RowContainer } from \"./row-container\";\nlet focusSearchTerm = \"\";\nlet timeoutId = null;\n/**\n * All these keyboard shortcuts seem like they should be configurable.\n * Each operation should be a given a name and separated from\n * the event handler. Future clean up welcome.\n */\nexport function DefaultContainer() {\n    useDataUpdates();\n    const tree = useTreeApi();\n    return (_jsx(\"div\", { role: \"tree\", style: {\n            height: tree.height,\n            width: tree.width,\n            minHeight: 0,\n            minWidth: 0,\n        }, onContextMenu: tree.props.onContextMenu, onClick: tree.props.onClick, tabIndex: 0, onFocus: (e) => {\n            if (!e.currentTarget.contains(e.relatedTarget)) {\n                tree.onFocus();\n            }\n        }, onBlur: (e) => {\n            if (!e.currentTarget.contains(e.relatedTarget)) {\n                tree.onBlur();\n            }\n        }, onKeyDown: (e) => {\n            var _a;\n            if (tree.isEditing) {\n                return;\n            }\n            if (e.key === \"Backspace\") {\n                if (!tree.props.onDelete)\n                    return;\n                const ids = Array.from(tree.selectedIds);\n                if (ids.length > 1) {\n                    let nextFocus = tree.mostRecentNode;\n                    while (nextFocus && nextFocus.isSelected) {\n                        nextFocus = nextFocus.nextSibling;\n                    }\n                    if (!nextFocus)\n                        nextFocus = tree.lastNode;\n                    tree.focus(nextFocus, { scroll: false });\n                    tree.delete(Array.from(ids));\n                }\n                else {\n                    const node = tree.focusedNode;\n                    if (node) {\n                        const sib = node.nextSibling;\n                        const parent = node.parent;\n                        tree.focus(sib || parent, { scroll: false });\n                        tree.delete(node);\n                    }\n                }\n                return;\n            }\n            if (e.key === \"Tab\" && !e.shiftKey) {\n                e.preventDefault();\n                focusNextElement(e.currentTarget);\n                return;\n            }\n            if (e.key === \"Tab\" && e.shiftKey) {\n                e.preventDefault();\n                focusPrevElement(e.currentTarget);\n                return;\n            }\n            if (e.key === \"ArrowDown\") {\n                e.preventDefault();\n                const next = tree.nextNode;\n                if (e.metaKey) {\n                    tree.select(tree.focusedNode);\n                    tree.activate(tree.focusedNode);\n                    return;\n                }\n                else if (!e.shiftKey || tree.props.disableMultiSelection) {\n                    tree.focus(next);\n                    return;\n                }\n                else {\n                    if (!next)\n                        return;\n                    const current = tree.focusedNode;\n                    if (!current) {\n                        tree.focus(tree.firstNode);\n                    }\n                    else if (current.isSelected) {\n                        tree.selectContiguous(next);\n                    }\n                    else {\n                        tree.selectMulti(next);\n                    }\n                    return;\n                }\n            }\n            if (e.key === \"ArrowUp\") {\n                e.preventDefault();\n                const prev = tree.prevNode;\n                if (!e.shiftKey || tree.props.disableMultiSelection) {\n                    tree.focus(prev);\n                    return;\n                }\n                else {\n                    if (!prev)\n                        return;\n                    const current = tree.focusedNode;\n                    if (!current) {\n                        tree.focus(tree.lastNode); // ?\n                    }\n                    else if (current.isSelected) {\n                        tree.selectContiguous(prev);\n                    }\n                    else {\n                        tree.selectMulti(prev);\n                    }\n                    return;\n                }\n            }\n            if (e.key === \"ArrowRight\") {\n                const node = tree.focusedNode;\n                if (!node)\n                    return;\n                if (node.isInternal && node.isOpen) {\n                    tree.focus(tree.nextNode);\n                }\n                else if (node.isInternal)\n                    tree.open(node.id);\n                return;\n            }\n            if (e.key === \"ArrowLeft\") {\n                const node = tree.focusedNode;\n                if (!node || node.isRoot)\n                    return;\n                if (node.isInternal && node.isOpen)\n                    tree.close(node.id);\n                else if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)) {\n                    tree.focus(node.parent);\n                }\n                return;\n            }\n            if (e.key === \"a\" && e.metaKey && !tree.props.disableMultiSelection) {\n                e.preventDefault();\n                tree.selectAll();\n                return;\n            }\n            if (e.key === \"a\" && !e.metaKey && tree.props.onCreate) {\n                tree.createLeaf();\n                return;\n            }\n            if (e.key === \"A\" && !e.metaKey) {\n                if (!tree.props.onCreate)\n                    return;\n                tree.createInternal();\n                return;\n            }\n            if (e.key === \"Home\") {\n                // add shift keys\n                e.preventDefault();\n                tree.focus(tree.firstNode);\n                return;\n            }\n            if (e.key === \"End\") {\n                // add shift keys\n                e.preventDefault();\n                tree.focus(tree.lastNode);\n                return;\n            }\n            if (e.key === \"Enter\") {\n                const node = tree.focusedNode;\n                if (!node)\n                    return;\n                if (!node.isEditable || !tree.props.onRename)\n                    return;\n                setTimeout(() => {\n                    if (node)\n                        tree.edit(node);\n                });\n                return;\n            }\n            if (e.key === \" \") {\n                e.preventDefault();\n                const node = tree.focusedNode;\n                if (!node)\n                    return;\n                if (node.isLeaf) {\n                    node.select();\n                    node.activate();\n                }\n                else {\n                    node.toggle();\n                }\n                return;\n            }\n            if (e.key === \"*\") {\n                const node = tree.focusedNode;\n                if (!node)\n                    return;\n                tree.openSiblings(node);\n                return;\n            }\n            if (e.key === \"PageUp\") {\n                e.preventDefault();\n                tree.pageUp();\n                return;\n            }\n            if (e.key === \"PageDown\") {\n                e.preventDefault();\n                tree.pageDown();\n            }\n            // If they type a sequence of characters\n            // collect them. Reset them after a timeout.\n            // Use it to search the tree for a node, then focus it.\n            // Clean this up a bit later\n            clearTimeout(timeoutId);\n            focusSearchTerm += e.key;\n            timeoutId = setTimeout(() => {\n                focusSearchTerm = \"\";\n            }, 600);\n            const node = tree.visibleNodes.find((n) => {\n                // @ts-ignore\n                const name = n.data.name;\n                if (typeof name === \"string\") {\n                    return name.toLowerCase().startsWith(focusSearchTerm);\n                }\n                else\n                    return false;\n            });\n            if (node)\n                tree.focus(node.id);\n        }, children: _jsx(FixedSizeList, { className: tree.props.className, outerRef: tree.listEl, itemCount: tree.visibleNodes.length, height: tree.height, width: tree.width, itemSize: tree.rowHeight, overscanCount: tree.overscanCount, itemKey: (index) => { var _a; return ((_a = tree.visibleNodes[index]) === null || _a === void 0 ? void 0 : _a.id) || index; }, outerElementType: ListOuterElement, innerElementType: ListInnerElement, onScroll: tree.props.onScroll, onItemsRendered: tree.onItemsRendered.bind(tree), ref: tree.list, children: RowContainer }) }));\n}\n"],"mappings":"AAAA,SAASA,GAAG,IAAIC,IAAI,QAAQ,mBAAmB;AAC/C,SAASC,aAAa,QAAQ,cAAc;AAC5C,SAASC,cAAc,EAAEC,UAAU,QAAQ,YAAY;AACvD,SAASC,gBAAgB,EAAEC,gBAAgB,QAAQ,UAAU;AAC7D,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,IAAIC,eAAe,GAAG,EAAE;AACxB,IAAIC,SAAS,GAAG,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAAA,EAAG;EAC/BT,cAAc,CAAC,CAAC;EAChB,MAAMU,IAAI,GAAGT,UAAU,CAAC,CAAC;EACzB,OAAQH,IAAI,CAAC,KAAK,EAAE;IAAEa,IAAI,EAAE,MAAM;IAAEC,KAAK,EAAE;MACnCC,MAAM,EAAEH,IAAI,CAACG,MAAM;MACnBC,KAAK,EAAEJ,IAAI,CAACI,KAAK;MACjBC,SAAS,EAAE,CAAC;MACZC,QAAQ,EAAE;IACd,CAAC;IAAEC,aAAa,EAAEP,IAAI,CAACQ,KAAK,CAACD,aAAa;IAAEE,OAAO,EAAET,IAAI,CAACQ,KAAK,CAACC,OAAO;IAAEC,QAAQ,EAAE,CAAC;IAAEC,OAAO,EAAGC,CAAC,IAAK;MAClG,IAAI,CAACA,CAAC,CAACC,aAAa,CAACC,QAAQ,CAACF,CAAC,CAACG,aAAa,CAAC,EAAE;QAC5Cf,IAAI,CAACW,OAAO,CAAC,CAAC;MAClB;IACJ,CAAC;IAAEK,MAAM,EAAGJ,CAAC,IAAK;MACd,IAAI,CAACA,CAAC,CAACC,aAAa,CAACC,QAAQ,CAACF,CAAC,CAACG,aAAa,CAAC,EAAE;QAC5Cf,IAAI,CAACgB,MAAM,CAAC,CAAC;MACjB;IACJ,CAAC;IAAEC,SAAS,EAAGL,CAAC,IAAK;MACjB,IAAIM,EAAE;MACN,IAAIlB,IAAI,CAACmB,SAAS,EAAE;QAChB;MACJ;MACA,IAAIP,CAAC,CAACQ,GAAG,KAAK,WAAW,EAAE;QACvB,IAAI,CAACpB,IAAI,CAACQ,KAAK,CAACa,QAAQ,EACpB;QACJ,MAAMC,GAAG,GAAGC,KAAK,CAACC,IAAI,CAACxB,IAAI,CAACyB,WAAW,CAAC;QACxC,IAAIH,GAAG,CAACI,MAAM,GAAG,CAAC,EAAE;UAChB,IAAIC,SAAS,GAAG3B,IAAI,CAAC4B,cAAc;UACnC,OAAOD,SAAS,IAAIA,SAAS,CAACE,UAAU,EAAE;YACtCF,SAAS,GAAGA,SAAS,CAACG,WAAW;UACrC;UACA,IAAI,CAACH,SAAS,EACVA,SAAS,GAAG3B,IAAI,CAAC+B,QAAQ;UAC7B/B,IAAI,CAACgC,KAAK,CAACL,SAAS,EAAE;YAAEM,MAAM,EAAE;UAAM,CAAC,CAAC;UACxCjC,IAAI,CAACkC,MAAM,CAACX,KAAK,CAACC,IAAI,CAACF,GAAG,CAAC,CAAC;QAChC,CAAC,MACI;UACD,MAAMa,IAAI,GAAGnC,IAAI,CAACoC,WAAW;UAC7B,IAAID,IAAI,EAAE;YACN,MAAME,GAAG,GAAGF,IAAI,CAACL,WAAW;YAC5B,MAAMQ,MAAM,GAAGH,IAAI,CAACG,MAAM;YAC1BtC,IAAI,CAACgC,KAAK,CAACK,GAAG,IAAIC,MAAM,EAAE;cAAEL,MAAM,EAAE;YAAM,CAAC,CAAC;YAC5CjC,IAAI,CAACkC,MAAM,CAACC,IAAI,CAAC;UACrB;QACJ;QACA;MACJ;MACA,IAAIvB,CAAC,CAACQ,GAAG,KAAK,KAAK,IAAI,CAACR,CAAC,CAAC2B,QAAQ,EAAE;QAChC3B,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBhD,gBAAgB,CAACoB,CAAC,CAACC,aAAa,CAAC;QACjC;MACJ;MACA,IAAID,CAAC,CAACQ,GAAG,KAAK,KAAK,IAAIR,CAAC,CAAC2B,QAAQ,EAAE;QAC/B3B,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClB/C,gBAAgB,CAACmB,CAAC,CAACC,aAAa,CAAC;QACjC;MACJ;MACA,IAAID,CAAC,CAACQ,GAAG,KAAK,WAAW,EAAE;QACvBR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClB,MAAMC,IAAI,GAAGzC,IAAI,CAAC0C,QAAQ;QAC1B,IAAI9B,CAAC,CAAC+B,OAAO,EAAE;UACX3C,IAAI,CAAC4C,MAAM,CAAC5C,IAAI,CAACoC,WAAW,CAAC;UAC7BpC,IAAI,CAAC6C,QAAQ,CAAC7C,IAAI,CAACoC,WAAW,CAAC;UAC/B;QACJ,CAAC,MACI,IAAI,CAACxB,CAAC,CAAC2B,QAAQ,IAAIvC,IAAI,CAACQ,KAAK,CAACsC,qBAAqB,EAAE;UACtD9C,IAAI,CAACgC,KAAK,CAACS,IAAI,CAAC;UAChB;QACJ,CAAC,MACI;UACD,IAAI,CAACA,IAAI,EACL;UACJ,MAAMM,OAAO,GAAG/C,IAAI,CAACoC,WAAW;UAChC,IAAI,CAACW,OAAO,EAAE;YACV/C,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAACgD,SAAS,CAAC;UAC9B,CAAC,MACI,IAAID,OAAO,CAAClB,UAAU,EAAE;YACzB7B,IAAI,CAACiD,gBAAgB,CAACR,IAAI,CAAC;UAC/B,CAAC,MACI;YACDzC,IAAI,CAACkD,WAAW,CAACT,IAAI,CAAC;UAC1B;UACA;QACJ;MACJ;MACA,IAAI7B,CAAC,CAACQ,GAAG,KAAK,SAAS,EAAE;QACrBR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClB,MAAMW,IAAI,GAAGnD,IAAI,CAACoD,QAAQ;QAC1B,IAAI,CAACxC,CAAC,CAAC2B,QAAQ,IAAIvC,IAAI,CAACQ,KAAK,CAACsC,qBAAqB,EAAE;UACjD9C,IAAI,CAACgC,KAAK,CAACmB,IAAI,CAAC;UAChB;QACJ,CAAC,MACI;UACD,IAAI,CAACA,IAAI,EACL;UACJ,MAAMJ,OAAO,GAAG/C,IAAI,CAACoC,WAAW;UAChC,IAAI,CAACW,OAAO,EAAE;YACV/C,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAAC+B,QAAQ,CAAC,CAAC,CAAC;UAC/B,CAAC,MACI,IAAIgB,OAAO,CAAClB,UAAU,EAAE;YACzB7B,IAAI,CAACiD,gBAAgB,CAACE,IAAI,CAAC;UAC/B,CAAC,MACI;YACDnD,IAAI,CAACkD,WAAW,CAACC,IAAI,CAAC;UAC1B;UACA;QACJ;MACJ;MACA,IAAIvC,CAAC,CAACQ,GAAG,KAAK,YAAY,EAAE;QACxB,MAAMe,IAAI,GAAGnC,IAAI,CAACoC,WAAW;QAC7B,IAAI,CAACD,IAAI,EACL;QACJ,IAAIA,IAAI,CAACkB,UAAU,IAAIlB,IAAI,CAACmB,MAAM,EAAE;UAChCtD,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAAC0C,QAAQ,CAAC;QAC7B,CAAC,MACI,IAAIP,IAAI,CAACkB,UAAU,EACpBrD,IAAI,CAACuD,IAAI,CAACpB,IAAI,CAACqB,EAAE,CAAC;QACtB;MACJ;MACA,IAAI5C,CAAC,CAACQ,GAAG,KAAK,WAAW,EAAE;QACvB,MAAMe,IAAI,GAAGnC,IAAI,CAACoC,WAAW;QAC7B,IAAI,CAACD,IAAI,IAAIA,IAAI,CAACsB,MAAM,EACpB;QACJ,IAAItB,IAAI,CAACkB,UAAU,IAAIlB,IAAI,CAACmB,MAAM,EAC9BtD,IAAI,CAAC0D,KAAK,CAACvB,IAAI,CAACqB,EAAE,CAAC,CAAC,KACnB,IAAI,EAAE,CAACtC,EAAE,GAAGiB,IAAI,CAACG,MAAM,MAAM,IAAI,IAAIpB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACuC,MAAM,CAAC,EAAE;UAC3EzD,IAAI,CAACgC,KAAK,CAACG,IAAI,CAACG,MAAM,CAAC;QAC3B;QACA;MACJ;MACA,IAAI1B,CAAC,CAACQ,GAAG,KAAK,GAAG,IAAIR,CAAC,CAAC+B,OAAO,IAAI,CAAC3C,IAAI,CAACQ,KAAK,CAACsC,qBAAqB,EAAE;QACjElC,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBxC,IAAI,CAAC2D,SAAS,CAAC,CAAC;QAChB;MACJ;MACA,IAAI/C,CAAC,CAACQ,GAAG,KAAK,GAAG,IAAI,CAACR,CAAC,CAAC+B,OAAO,IAAI3C,IAAI,CAACQ,KAAK,CAACoD,QAAQ,EAAE;QACpD5D,IAAI,CAAC6D,UAAU,CAAC,CAAC;QACjB;MACJ;MACA,IAAIjD,CAAC,CAACQ,GAAG,KAAK,GAAG,IAAI,CAACR,CAAC,CAAC+B,OAAO,EAAE;QAC7B,IAAI,CAAC3C,IAAI,CAACQ,KAAK,CAACoD,QAAQ,EACpB;QACJ5D,IAAI,CAAC8D,cAAc,CAAC,CAAC;QACrB;MACJ;MACA,IAAIlD,CAAC,CAACQ,GAAG,KAAK,MAAM,EAAE;QAClB;QACAR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBxC,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAACgD,SAAS,CAAC;QAC1B;MACJ;MACA,IAAIpC,CAAC,CAACQ,GAAG,KAAK,KAAK,EAAE;QACjB;QACAR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBxC,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAAC+B,QAAQ,CAAC;QACzB;MACJ;MACA,IAAInB,CAAC,CAACQ,GAAG,KAAK,OAAO,EAAE;QACnB,MAAMe,IAAI,GAAGnC,IAAI,CAACoC,WAAW;QAC7B,IAAI,CAACD,IAAI,EACL;QACJ,IAAI,CAACA,IAAI,CAAC4B,UAAU,IAAI,CAAC/D,IAAI,CAACQ,KAAK,CAACwD,QAAQ,EACxC;QACJC,UAAU,CAAC,MAAM;UACb,IAAI9B,IAAI,EACJnC,IAAI,CAACkE,IAAI,CAAC/B,IAAI,CAAC;QACvB,CAAC,CAAC;QACF;MACJ;MACA,IAAIvB,CAAC,CAACQ,GAAG,KAAK,GAAG,EAAE;QACfR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClB,MAAML,IAAI,GAAGnC,IAAI,CAACoC,WAAW;QAC7B,IAAI,CAACD,IAAI,EACL;QACJ,IAAIA,IAAI,CAACgC,MAAM,EAAE;UACbhC,IAAI,CAACS,MAAM,CAAC,CAAC;UACbT,IAAI,CAACU,QAAQ,CAAC,CAAC;QACnB,CAAC,MACI;UACDV,IAAI,CAACiC,MAAM,CAAC,CAAC;QACjB;QACA;MACJ;MACA,IAAIxD,CAAC,CAACQ,GAAG,KAAK,GAAG,EAAE;QACf,MAAMe,IAAI,GAAGnC,IAAI,CAACoC,WAAW;QAC7B,IAAI,CAACD,IAAI,EACL;QACJnC,IAAI,CAACqE,YAAY,CAAClC,IAAI,CAAC;QACvB;MACJ;MACA,IAAIvB,CAAC,CAACQ,GAAG,KAAK,QAAQ,EAAE;QACpBR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBxC,IAAI,CAACsE,MAAM,CAAC,CAAC;QACb;MACJ;MACA,IAAI1D,CAAC,CAACQ,GAAG,KAAK,UAAU,EAAE;QACtBR,CAAC,CAAC4B,cAAc,CAAC,CAAC;QAClBxC,IAAI,CAACuE,QAAQ,CAAC,CAAC;MACnB;MACA;MACA;MACA;MACA;MACAC,YAAY,CAAC1E,SAAS,CAAC;MACvBD,eAAe,IAAIe,CAAC,CAACQ,GAAG;MACxBtB,SAAS,GAAGmE,UAAU,CAAC,MAAM;QACzBpE,eAAe,GAAG,EAAE;MACxB,CAAC,EAAE,GAAG,CAAC;MACP,MAAMsC,IAAI,GAAGnC,IAAI,CAACyE,YAAY,CAACC,IAAI,CAAEC,CAAC,IAAK;QACvC;QACA,MAAMC,IAAI,GAAGD,CAAC,CAACE,IAAI,CAACD,IAAI;QACxB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;UAC1B,OAAOA,IAAI,CAACE,WAAW,CAAC,CAAC,CAACC,UAAU,CAAClF,eAAe,CAAC;QACzD,CAAC,MAEG,OAAO,KAAK;MACpB,CAAC,CAAC;MACF,IAAIsC,IAAI,EACJnC,IAAI,CAACgC,KAAK,CAACG,IAAI,CAACqB,EAAE,CAAC;IAC3B,CAAC;IAAEwB,QAAQ,EAAE5F,IAAI,CAACC,aAAa,EAAE;MAAE4F,SAAS,EAAEjF,IAAI,CAACQ,KAAK,CAACyE,SAAS;MAAEC,QAAQ,EAAElF,IAAI,CAACmF,MAAM;MAAEC,SAAS,EAAEpF,IAAI,CAACyE,YAAY,CAAC/C,MAAM;MAAEvB,MAAM,EAAEH,IAAI,CAACG,MAAM;MAAEC,KAAK,EAAEJ,IAAI,CAACI,KAAK;MAAEiF,QAAQ,EAAErF,IAAI,CAACsF,SAAS;MAAEC,aAAa,EAAEvF,IAAI,CAACuF,aAAa;MAAEC,OAAO,EAAGC,KAAK,IAAK;QAAE,IAAIvE,EAAE;QAAE,OAAO,CAAC,CAACA,EAAE,GAAGlB,IAAI,CAACyE,YAAY,CAACgB,KAAK,CAAC,MAAM,IAAI,IAAIvE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACsC,EAAE,KAAKiC,KAAK;MAAE,CAAC;MAAEC,gBAAgB,EAAEhG,gBAAgB;MAAEiG,gBAAgB,EAAEhG,gBAAgB;MAAEiG,QAAQ,EAAE5F,IAAI,CAACQ,KAAK,CAACoF,QAAQ;MAAEC,eAAe,EAAE7F,IAAI,CAAC6F,eAAe,CAACC,IAAI,CAAC9F,IAAI,CAAC;MAAE+F,GAAG,EAAE/F,IAAI,CAACgG,IAAI;MAAEhB,QAAQ,EAAEpF;IAAa,CAAC;EAAE,CAAC,CAAC;AACjjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}